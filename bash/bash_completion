# 可将编写好的脚本在用户根目录.bash_profile中进行调用，亦可放于/etc/bash_completion 或 /etc/bash_completion.d/bash_completion下，这样在下次登录终端时即可自动source自动补全脚本。
# git 补全脚本: https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
# complete -F _complete_func git
complete -F _complete_func test_complete
complete -F _complete_func git.sh
complete -F _complete_func python.sh
complete -F _complete_func mvn.sh
complete -F _complete_func download.sh
complete -F _complete_func mvn
complete -F _complete_func vimspector.sh
complete -F _complete_func you-get # 爬取视频工具,使用 `pip3 install you-get` 安装
# complete -F _complete_func pandoc # 文件格式转换工具, 比如epub转pdf 
# complete -F _complete_func pandoc # 文件格式转换工具, 比如epub转pdf, 使用 `apt install calibre` 安装



# 提示列表
cmd_list=()
# 某一个具体的提示命令
cmd_item_list=()
# cmd_item_list长度
cmd_item_list_length=0
# cmd_item_list的某个提示项
cmd_item=""
# cmd_item运行参赛
cmd_item_data=("type: cmd类型" 
    "index: 需要添加提示下标列表(该下标相对于item_index)比如 (-1 0 1 2) 真实下标为 (item_index-1 item_index item_index+1 item_index+2)"
)
# cmd 转换成list的匹配下标
item_index=0
# 用户输入的匹配下标
comp_index=0
# 用户输入的匹配项
comp_cmd_item=""
# 最后提示的命令文本
global_completion_txt=""

_complete_func() {

    # COMP_WORDS: 类型为数组，存放当前命令行中输入的所有单词
    # COMP_CWORD: 型为整数，当前输入的单词在COMP_WORDS中的索引
    # COMPREPLY: 类型为数组，候选的补全结果
    # COMP_WORDBREAKS: 类型为字符串，表示单词之间的分隔符
    # COMP_LINE: 类型为字符串，表示当前的命令行输入字符
    # COMP_POINT: 类型为整数，表示光标在当前命令行的哪个位置


    # 命令参数
    # "-o bashdefault”：如果没有生成补全条目，就使用bash默认的其它补全。
    # "-o default”：如果没有生成补全条目，就使用"readline”默认的文件名补全。
    # "-o dirnames”：如果没有生成补全条目，就进行目录名补全。
    # "-o filenames”：告诉"readline”生成文件名，以便进行与文件名相关的处理，例如在目录名后面加上斜杠，引用特殊字符，去掉行尾的空格，目的是用于shell函数。
    # "-o noquote”：告诉"readline”不引用文件名，默认会进行引用。
    # "-o nospace”：告诉"readline”在补全的名称后不添加空格，默认添加空格。
    # "-o plusdirs”：生成补全条目之后，还会进行目录名补全并把结果添加到其它动作得到的结果中。
    # "-A alias”：别名，同选项"-a”。
    # "-A arrayvar”：数组变量名。
    # "-A binding”："readline”键绑定名。
    # "-A builtin”：shell内建命令名，同选项"-b”。
    # "-A command”：命令名，同选项"-c”。
    # "-A directory”：目录名，同选项"-d”。
    # "-A disabled”：不可用的shell内建命令名。
    # "-A enabled”：可用的shell内建命令名。
    # "-A export”：导出的shell变量名，同选项"-e”。
    # "-A file”：文件名，同选项"-f”。
    # "-A function”：shell函数名。
    # "-A group”：组名，同选项"-g”。
    # "-A helptopic”：内建命令help支持的帮助主题。
    # "-A hostname”：主机名，从shell环境变量HOSTFILE中获取。
    # "-A job”：作业名，同选项"-j”。
    # "-A keyword”：shell保留字，同选项"-k”。
    # "-A running”：正在运行的作业名。
    # "-A service”：服务名，同选项"-s”。
    # "-A setopt”：内建命令set的选项"-o”可用的参数。
    # "-A shopt”：内建命令shopt可接受的选项名。
    # "-A signal”：信号名。
    # "-A stopped”：暂停的作业名。
    # "-A user”：用户名，同选项"-u”。
    # "-A variable”：所有的shell变量名，同选项"-v”。
    # "-C command”：在子shell中执行命令，并把其结果作为补全条目。
    # "-F function”：在当前的shell环境中执行函数function，执行时，参数"$1”表示那个参数正在进行补全的命令名，参数"$2”表示补全的名称，参数"$3”表示补全的名称前面的单词，表示结束执行时，从数组变量COMPREPLY中获取补全条目。
    # "-G globpat”：使用文件名扩展模式globpat进行扩展以生成可能的补全条目。
    # "-P prefix”：在所有的选项应用到补全结果后，在结果前添加前缀prefix。
    # "-S suffix”：在所有的选项应用到补全结果后，在结果后添加后缀suffix。
    # "-W wordlist”：使用特殊变量IFS中的字符拆分单词列表wordlist，并扩展拆分后的每个单词，结果中与待补全单词匹配的条目就是补全条目。
    # "-X filterpat”：filterpat是进行文件名扩展时使用的模式，它作用于通过前面的选项和参数生成的补全列表，并把每个与过滤模式匹配的条目删除，模式中前导的叹号表示否定，这时会删除与过滤模式不匹配的条目。

    # 将之前的提示给清理掉
    global_completion_txt=""

    local original_cmd=${COMP_WORDS[0]}

    # cmd_list 编写规则:
    # 格式如下 : cmd_list=("$cmd_item $cmd_item  '{option:value}'  ...")
    # 1. cmd_list中的每个元素为提示的完整命令行
    # 4. 如果cmd_item带空格可以用''(单引号)包裹
    # 3. 选项模式: cmd_item支持{option:value}形式, 该形式,并且不比较与原始的shell命令, option支持如下情况
    #   3.1 {value} : 原样输出{value}目的是为了提示后面输入
    #   3.2 {cmd:value} : 输出value执行结果即 eval $value
    #   3.3 {-filenames} : 非提示, 但是将 complete 改成文件提示模式, 即按tab的时候不会自动在最后添加空格(space)
    #   3.4 {or:("cmd_item1" "cmd_item2" ...)}, 该形式为支持 cmd_item1 cmd_item2 乱顺提示
    #       即 cmd_item1 后可以提示cmd_item2, 反之亦然
    #   3.5 {and:("cmd_item1" "cmd_item2" "cmd_item3" ...)}, 该形式需要按照顺序匹配cmd_item1 cmd_item2 cmd_item3,
    #       即 cmd_item1 会提示出 cmd_item2 cmd_item3 , 但cmd_item1 cmd_item2 会提示出 cmd_item3
    #       但 直接输入 cmd_item2 不匹配, 因为 cmd_item2 前无 cmd_item1 (需要完全按照匹配)
    #       and 匹配模式一般用于kv的匹配比如 docker -v docker目录:宿主机目录 , 其中-v docker目录:宿主机目录就是 kv
    # 通用的命令提示如下
    # 1. {cmd:_comp_file_direct_} : 提示的文件列表

    if [[ "$original_cmd" == "python.sh" ]]; then
        cmd_list=("python.sh --help" # 查看帮助文档 
            "python.sh setuptools env" # 安装构建/打包的相关依赖
            "python.sh setuptools init {项目名}" # 初始化一个可打包python项目
            "python.sh setuptools install" # 将本地python项目安装到site-packages
            "python.sh setuptools build" # 打包本地python项目,在./dist 生成文件夹
            "python.sh test {cmd:_comp_file_direct_}" # 运行单元测试用例, 等价于 python setup.py test
        )

    elif [[ "$original_cmd" == "test_complete" ]]; then
        cmd_list=("test_complete or '{or:(-d -l)}' -t -f"
            "test_complete and '{and:(-v \"{dir}\")}' -t -f"
            "test_complete and_or '{or:(\"{and:(-v {dir})}\" \"{and:(-d {dir})}\")}' -t -f")

    elif [[ "$original_cmd" == "git" ]]; then
        cmd_list=("git --help" # 查看帮助文档

            # git stash : 将目前还不想提交的但是已经修改的内容进行暂存至堆栈
            "git stash push -m {提交消息用双引号包裹}" # 将修改内容暂存至stash暂存区(为一个栈), 并且使用消息
            "git stash list" # 查看当前stash暂存区中的内容
            "git stash pop" # 将当前stash中的内容弹出，并应用到当前分支对应的工作目录上, 命令将堆栈中最近保存的内容删除（栈是先进后出）
            "git stash pop {stash暂存栈下标}" # 将指定stash栈的内容弹出，并应用到当前分支对应的工作目录上, 比如git stash pop stash@{1}
            "git stash apply" # 将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除
            "git stash drop {stash暂存栈下标}" # 从stash堆栈中移除某个指定的stash, 比如 git stash drop stash@{0}
            "git stash clear" # 清除stash堆栈中的所有内容
            "git stash show" # 查看堆栈中最新保存的stash和当前目录的差异。
            "git stash show {stash暂存栈下标} -p" # 查看堆栈中指定保存的stash和当前目录的差异。比如  git stash show stash@{1} -p 
            "git stash create" # 它创建了一个暂存条目，并返回它的对象名，而不将其推送到暂存参考日志中返回值配合 git stash store -m "消息" ${git stash create}
            "git stash store -m {消息} {gitStashCreate执行结果}" # 创建的暂存条目推送到暂存参考日志
            "git stash branch {分支名} {stash暂存栈下标}" # 此命令使用指定的stash创建一个新分支，然后删除指定的存储, git stash branch new_branch stash@{1}
            )
        
    elif [[ "$original_cmd" == "git.sh" ]]; then
        cmd_list=("git.sh --help" # 查看帮助文档
            "git.sh upstream {上游git地址}" # Git进行fork后跟原仓库同步,会添加一个上游的主干分支 upstream/master
            "git.sh github repos {github组织} {pageSize:30}" # git clone github上一个组织(organizations)下的所有存储库
            "git.sh github upstreamUrl" # 解析github项目上游url
            "git.sh reset version {git_commit_id}" # git回滚到某个版本
            "git.sh reset add {cmd:_comp_file_direct_}" # git撤销add 文件列表
            "git.sh init_server {项目名}" # 初始化git服务端项目,供git clone user@ip:/项目路径
            "git.sh pull" # 将当前目录下的所有git项目pull
        )
    elif [[ "$original_cmd" == "mvn.sh" ]]; then
        cmd_list=("mvn.sh --help" # 查看mvn.sh脚本帮助文档
            "mvn.sh find_main {过滤字符1} {过滤字符2}" # 扫描本目录下所有的main java
            "mvn.sh deploy '{cmd:mvn.sh find_main src/main}'" # 部署maven项目,运行前强制打包编译
            "mvn.sh run '{cmd:mvn.sh find_main src/main}'" # 运行maven项目,只是编译不打包,开启远程debug,远程端口5005,不阻塞启动
            "mvn.sh debug '{cmd:mvn.sh find_main src/main}'" # 运行maven项目,只是编译不打包,开启远程debug,远程端口5005,阻塞启动
            "mvn.sh init jar" # 初始化普通maven项目, 打包为jar
        )
    elif [[ "$original_cmd" == "download.sh" ]]; then
        cmd_list=("download.sh --help" # 脚本帮助文档
            "download.sh {url文件存储路径} {下载目录}" # 下载多个文件到某个目录
        )
    elif [[ "$original_cmd" == "mvn" ]]; then
        cmd_list=("mvn clean install -Dmaven.test.skip=true" # 编译打包maven项目,跳过测试类(不执行测试用例，也不编译测试用例类),不执行测试用例，也不编译测试用例类
            "mvn dependency:sources -DdownloadJavadocs=true" # 下载maven依赖pom的源码和doc
            "mvn dependency:tree" # 查看pom依赖树
            "mvn compile" # 编译maven项目
            "mvn compiler:compile" # 编译maven项目
        )
    elif [[ "$original_cmd" == "vimspector.sh" ]]; then
        cmd_list=("vimspector.sh --help" # 查看帮助文档
            "vimspector.sh language" # 查看支持的语言
            "vimspector.sh config '{cmd:vimspector.sh language}'" # 复制对应语言的配置到本目录下,在本地生成 .vimspector.json 文件
        )
    elif [[ "$original_cmd" == "you-get" ]]; then
        cmd_list=("you-get -l {视频网址}" # 下载视频列表(下载多个)
            "you-get {视频网址}" # 下载单个视频
        )
    elif [[ "$original_cmd" == "pandoc" ]]; then
        cmd_list=("pandoc {cmd:_comp_file_direct_} -o {输出文件名} --pdf-engine=xelatex" # pandoc 文件格式转换如果需要转pdf需要安装latex 
        )
    elif [[ "$original_cmd" = "ebook-convert" ]]; then
        # ebook-convert 转换电纸书格式, 支持pdf, epub等
        # --base-font-size: 基准字体大小（以PT为单位）。在生成的书籍中所有的字体尺寸将基于这个大小重新缩放。通过选择更大的尺寸，可以使输出中的字体更大，反之亦然。默认情况下，当值为0时，根据你选择的'输出配置'确定基准字体大小
        # --line-height: 行高（以PT为单位）。控制连续文本行之间的行高。仅适用于未定义自身行高的内容元素。大多数情况下，最小行高值更加有用。默认不做行高调整
        # --embed-all-fonts: 嵌入输入文档中引用到但未嵌入的字体。软件会在你的系统中查找这些字体，找到了就嵌入。字体嵌入只有当你的目标格式支持时才有用，例如 EPUB、AZW3、DOCX 和 PDF。请保证你拥有在文档中嵌入字体的合适授权。 
        # --embed-font-family: 在书籍中嵌入指定的字体。这里指定了书籍中使用的“基础”字体。如果输入文件指定了字体，就有可能覆盖此处的基础字体。你可以使用“过滤样式信息”的选项来删除输入文档中指定的字体。注意，字体内嵌只在一些输出格式中有用，主要是 EPUB、AZW3 和 DOCX。
        cmd_list=("ebook-convert {input_file} {out_file} --base-font-size=12 --line-height=18 --embed-all-fonts --embed-font-family='AR PL SungtiL GB'"
            )

    fi

    COMPREPLY=()
    local command_name="${COMP_WORDS[COMP_CWORD]}"

    local i
    for(( i=0; i<${#cmd_list[@]}; i++)) do
        eval cmd_item_list=(${cmd_list[i]})
        cmd_item_list_length=${#cmd_item_list[@]}
        
        # 匹配的次数/要提示的位置,重置, 并且重置相关数据
        item_index=0
        _cmd_index_index_shift
        comp_index=0
        _comp_cmd_index_index_shift
        while (( comp_index<$COMP_CWORD && item_index<cmd_item_list_length )); do

            # 匹配单个命令
            _is_match_cmd 
            if (( $?>200 )); then
                # 如果执行不匹配则退出
                break
            fi
        done
    done

    # 输出tab提示
    COMPREPLY=($(compgen -W "${global_completion_txt}" -- ${command_name}))
    return 0
}

# 变动item_index, 并且将相关数据也跟在变动
_cmd_index_index_shift() {
    local index_shift="$1"
    test -z "$index_shift" && index_shift="0"
    # 先变item_index
    (( item_index=item_index+index_shift ))
    cmd_item=${cmd_item_list[item_index]}
    eval cmd_item_data=($(_parse_cmd_item_data_ "$cmd_item"))
}

# 变动comp_item_index, 并且将相关数据也跟在变动, 可能会触发提示
# 需要保证_comp_cmd_index_index_shift在_cmd_index_index_shift前执行
_comp_cmd_index_index_shift() {
    local comp_index_shift="$1"
    test -z "$comp_index_shift" && comp_index_shift="0"

    # 是否关闭comp_item_index的提示, 0:关闭, 非0打开
    local close_comp="$2"
    test -z "$close_comp" && close_comp="1"

    # 先变item_index
    (( comp_index=comp_index+comp_index_shift ))
    comp_cmd_item=${COMP_WORDS[comp_index]}

    if (( comp_index_shift!=0 && close_comp!=0 )); then
        # 如果变化后已经匹配完全则直接直接触发提示
        if (( comp_index>=COMP_CWORD )); then
            local add_item_index
            local add_item_index_list=(${cmd_item_data[1]})
    
            for add_item_index in "${add_item_index_list[@]}"; do
                _completion_cmd_add "${cmd_item_list[item_index+add_item_index]}"
            done        
        fi
    fi

}


_parse_cmd_item_data_(){
    local cmd_str="$1"

    if [[ "$cmd_str" == "{-filenames}" ]]; then
        # 提示文件名模式
        echo '"filenames" "1"'
    elif `grep -E '^\{cmd:.*\}$' <<< "$cmd_str" > /dev/null`; then
        # 执行命令模式
        echo '"cmd" "1"'
    elif `grep -E '^\{or:.*\}$' <<< "$cmd_str" > /dev/null`; then
        # 多参数or模式, or模式需要提示下一个cmd_item(or模式支持完全不匹配)
        echo '"or" "0 1"'
    elif `grep -E '^\{and:.*\}$' <<< "$cmd_str" > /dev/null`; then
        # and模式 , and模式由匹配方法 _is_match_cmd_and 追加所以其实会导致一个提示重复添加的情况, 后续优化
        echo '"and" "1"'
    elif `grep -E '^\{.*\}$' <<< "$cmd_str" > /dev/null`; then
        # 注释
        echo '"note" "1"'
    else
        # 默认的匹配模式
        echo '"general" "1"'
    fi
}

# 是否命令行匹配
# result: [0-200]: 匹配成功, (200,]匹配失败
_is_match_cmd() {
    _is_match_cmd_simple
    return $?
}

# 是否命令行匹配
# result: true: 匹配成功, false: 匹配失败  
_is_match_cmd_simple() {

    local match_cmd_item="$1" 
    test -z "$match_cmd_item" && match_cmd_item="$cmd_item"

    local match_comp_cmd_item="$2"
    test -z "$match_comp_cmd_item" && match_comp_cmd_item="$comp_cmd_item"

    # item下标是否向前加n, 只有在匹配成功的时候生效
    local item_add_num="$3"
    test -z "$item_add_num" && item_add_num="1"

    # comp下标是否向前加n, 只有在匹配成功的时候生效
    local comp_add_num="$4"
    test -z "$comp_add_num" && comp_add_num="1"

    eval local match_cmd_item_data=($(_parse_cmd_item_data_ "$match_cmd_item"))

    if [[ "${match_cmd_item_data[0]}" == "general" ]]; then
        # 如果为普通的提示需要完全相等
        if [[ "$match_cmd_item" == "$match_comp_cmd_item" ]]; then
            _comp_cmd_index_index_shift "$comp_add_num"
            _cmd_index_index_shift "$item_add_num"
            return 0
        fi
    elif [[ "${match_cmd_item_data[0]}" == "cmd" ]]; then
        # 如果为命令模式暂时不考虑需要匹配防止cmd执行过久导致的性能问题
        _comp_cmd_index_index_shift "$comp_add_num"
        _cmd_index_index_shift "$item_add_num"
        return 0
    elif [[ "${match_cmd_item_data[0]}" == "note" ]]; then
        # 如果只是提示则直接匹配
        _comp_cmd_index_index_shift "$comp_add_num"
        _cmd_index_index_shift "$item_add_num"
        return 0
    elif [[ "${match_cmd_item_data[0]}" == "or" ]]; then
        _is_match_cmd_or "$match_cmd_item" "$match_comp_cmd_item" "$item_add_num" "$comp_add_num"
        return $?
    elif [[ "${match_cmd_item_data[0]}" == "and" ]]; then
        _is_match_cmd_and "$match_cmd_item" "$match_comp_cmd_item" "$item_add_num" "$comp_add_num"
        return $?
    fi


    # 不匹配
    return -1
}

# or 模式匹配
_is_match_cmd_or() {
    local match_cmd_item="$1" 
    test -z "$match_cmd_item" && match_cmd_item="$cmd_item"
    eval local multiple_cmd_item_list=$(_cmd_normaliza_ "$match_cmd_item" "or")

    local match_comp_cmd_item="$2"
    test -z "$match_comp_cmd_item" && match_comp_cmd_item="$comp_cmd_item"

    # item下标是否向前加n, 只有在匹配成功的时候生效
    local item_add_num="$3"
    test -z "$item_add_num" && item_add_num="1"

    # comp下标是否向前加n, 只有在匹配成功的时候生效
    local comp_add_num="$4"
    test -z "$comp_add_num" && comp_add_num="1"
   

    local close_comp="1"
    # 是否下移comp_index,默认不下移坐标
    local is_comp_index_shift="false"
    local multiple_cmd_item
    for multiple_cmd_item in "${multiple_cmd_item_list[@]}"; do
        _is_match_cmd_simple "$multiple_cmd_item" "$match_comp_cmd_item" "0" "0"
        local match_result="$?"
        if (( $match_result<=200 )); then
            # 如果有一个可以匹配则需要下移
            is_comp_index_shift="true"
        fi

        if (( $match_result==200 )); then
            # 全匹配也不下移提示
            close_comp="0"
        fi

        if (( $match_result>100 && $match_result<=200 )); then
            # 如果为 and 模式的不完全匹配则不下移,而且需要手动添加下匹配到的and的下一个
            if (( comp_index>=COMP_CWORD )); then
                eval local and_multiple_cmd_item_list=$(_cmd_normaliza_ "$multiple_cmd_item" "and") 
                _completion_cmd_add "${and_multiple_cmd_item_list[match_result-100]}"
            fi

            
            close_comp="0"
        fi

    done

    if $is_comp_index_shift; then
        _comp_cmd_index_index_shift "$comp_add_num" "$close_comp"
    else
        # 所有都不匹配,则需要下移自己的提示,是or的关系, 就算没有一个匹配也可以
        _cmd_index_index_shift "$item_add_num"
    fi



    return 0
}

# and 模式匹配
_is_match_cmd_and() {
    local match_cmd_item="$1" 
    test -z "$match_cmd_item" && match_cmd_item="$cmd_item"
    eval local multiple_cmd_item_list=$(_cmd_normaliza_ "$match_cmd_item" "and")

    local match_comp_cmd_item="$2"
    test -z "$match_comp_cmd_item" && match_comp_cmd_item="$comp_cmd_item"

    # item下标是否向前加n, 只有在匹配成功的时候生效
    local item_add_num="$3"
    test -z "$item_add_num" && item_add_num="1"

    # comp下标是否向前加n, 只有在匹配成功的时候生效
    local comp_add_num="$4"
    test -z "$comp_add_num" && comp_add_num="1"


    # 倒叙查看匹配的第一条数据
    local match_comp_index
    for (( match_comp_index = comp_index; match_comp_index >= 0; match_comp_index-- )); do
         _is_match_cmd_simple "${multiple_cmd_item_list[0]}" "${COMP_WORDS[match_comp_index]}" "0" "0"
        if (( $?<=200 )); then
            # 有找到匹配第一个下标的数据
            break
        fi
    done 

    if (( match_comp_index<0 )); then
        # 找不到匹配的
        return -1
    fi

    local i
    for(( i=0; match_comp_index<COMP_CWORD && match_comp_index<=comp_index && i<${#multiple_cmd_item_list[@]}; i++)) do
        _is_match_cmd_simple "${multiple_cmd_item_list[i]}" "${COMP_WORDS[match_comp_index]}" "0" "0"
        if (( $?>200 )); then
            # 如果有一个不匹配则直接结束
            return -1
        fi
        (( match_comp_index++ ))
    done

    if (( match_comp_index<=comp_index )); then
        # 为匹配成功
        return -1
    fi

    # 匹配成功往下走一个
    if (( i>=${#multiple_cmd_item_list[@]} )); then
        # 如果and完全匹配则跳过了
        _comp_cmd_index_index_shift "$comp_add_num"
        _cmd_index_index_shift "$item_add_num"

        if (( match_comp_index>=COMP_CWORD )); then 
            # 如果匹配到则往提示里加一个
            _completion_cmd_add "${multiple_cmd_item_list[i]}"
        fi

        # 完全匹配则返回100
        return 100
    else
        _comp_cmd_index_index_shift "$comp_add_num" "0"
    fi
    if (( match_comp_index>=COMP_CWORD )); then 
        # 如果匹配到则往提示里加一个
        _completion_cmd_add "${multiple_cmd_item_list[i]}"
        if (( i<${#multiple_cmd_item_list[@]} )); then
            # 如果有添加则返回200
            return 200
        else
            # 如果完全匹配而且到最后了, 则返回0让提示走辖区
            return 0
        fi
    fi

    # 如果是不完全匹配则返回 100 + n (匹配到地n个, 从1开始)
    local result=100
    (( result=result+i ))
    return $result

}


# 将 {option:cmd} 格式的字符串 中的cmd提取出来
_cmd_normaliza_() {
    local cmd=$1

    shift 1
    local option
    for option in $*; do
        local normaliza_cmd=$(echo $cmd | sed 's/{'$option':\(.*\)}/\1/g')
        if [[ ! -z $normaliza_cmd ]]; then
            echo "$normaliza_cmd"
            return
        fi
    done

}


# 添加到提示命令到提示中
_completion_cmd_add() {
    
    _completion_cmd_normaliza_ "$1"
    global_completion_txt=''$global_completion_txt' '$_completion_cmd_normaliza_result''
}

# 将提示出的命令格式化, 支持递归操作
_completion_cmd_normaliza_() {

    local completion_cmd="$1"


    if [[ -z $completion_cmd ]]; then
        _completion_cmd_normaliza_result=""
        # 为空不格式化
        return
    fi


    # completion_cmd栈用于支持递归操作
    local completion_cmd_stack=()
    # 最后归一化出的命令
    local completion_txt=""
    # 将命令推到completion_cmd_stack中
    completion_cmd_stack[${#completion_cmd_stack[@]}]="$completion_cmd"

    # 遍历completion_cmd_stack直到数组为空
    while (( ${#completion_cmd_stack[@]} > 0 )); do

        local completion_stack_cmd=${completion_cmd_stack[${#completion_cmd_stack[@]}-1]}
        unset completion_cmd_stack[${#completion_cmd_stack[@]}-1]


        eval local completion_stack_cmd_data=($(_parse_cmd_item_data_ "$completion_stack_cmd"))

        if [[ "${completion_stack_cmd_data[0]}" == "general" ]]; then
            # 如果为普通提示
            completion_txt="$completion_txt $completion_stack_cmd"
        elif [[ "${completion_stack_cmd_data[0]}" == "note" ]]; then
            # 如果为注释模式
            completion_txt="$completion_txt $completion_stack_cmd"
        elif [[ "${completion_stack_cmd_data[0]}" == "cmd" ]]; then
            # 如果 option 是cmd, 则需要执行cmd命令并将结果 push 到 completion_cmd_stack
            local completion_normaliza_cmd=$(_cmd_normaliza_ "$completion_stack_cmd" "cmd")
            local completion_normaliza_cmd_result=$(eval $completion_normaliza_cmd)
            # 使用eval保证 '' 包裹起来的元素不被拆分
            eval local completion_normaliza_cmd_result=($completion_normaliza_cmd_result)
            local completion_normaliza_cmd_item
            for completion_normaliza_cmd_item in "${completion_normaliza_cmd_result[@]}"; do
                completion_cmd_stack[${#completion_cmd_stack[@]}]=$completion_normaliza_cmd_item
            done

        elif [[ "${completion_stack_cmd_data[0]}" == "filenames" ]]; then
            # use a hack to enable file mode in bash < 4
            # 将 compgen 提示模式改成文件提示模式, 即按tab的时候不会自动在最后添加空格(space)
            compopt -o filenames +o nospace 2>/dev/null ||
            compgen -f /non-existing-dir/ >/dev/null ||
            true

        elif [[ "${completion_stack_cmd_data[0]}" == "or" ]]; then
            # 多参数模式
            eval local multiple_cmd_item_list=$(_cmd_normaliza_ "$completion_stack_cmd" "or")
            local multiple_cmd_item
            for multiple_cmd_item in "${multiple_cmd_item_list[@]}"; do
                eval local multiple_cmd_item_data=($(_parse_cmd_item_data_ "$multiple_cmd_item"))
                if [[ "${multiple_cmd_item_data[0]}" == "and" ]]; then
                     _is_match_cmd_and "$multiple_cmd_item" "" "0" "0"
                     if (( $?<=200 && $?>100 )); then
                        # 特殊逻辑兼容,在or模式中有个cmd_item是and模式,如果这个and模式不完全匹配则只提示这个and模式的命令
                        multiple_cmd_item_list=()
                    fi
                fi
            done

            for multiple_cmd_item in "${multiple_cmd_item_list[@]}"; do
               # 将多个提示追加到提示中
               completion_cmd_stack[${#completion_cmd_stack[@]}]=$multiple_cmd_item
            done

        elif [[ "${completion_stack_cmd_data[0]}" == "and" ]]; then
            # and 模式由匹配添加所以可能死循环
            _is_match_cmd_and "$completion_stack_cmd" "" "0" "0"
            if (( $?>200 )); then
                # 如果是完全不匹配说明可能是要最新的提示
                eval local multiple_cmd_item_list=$(_cmd_normaliza_ "$completion_stack_cmd" "and")
                completion_cmd_stack[${#completion_cmd_stack[@]}]=${multiple_cmd_item_list[0]}
            fi

        else
            # 未知的情况为了不报错也追加到提示中
            completion_txt="$completion_txt $completion_stack_cmd"
        fi

    done

    _completion_cmd_normaliza_result="$completion_txt"

}


# 文件提示(提示会有多少文件), 请注意调用这个模式后会倒置 compgen 提示模式改成文件提示模式
_comp_file_direct_() {

    # 认为最后输入的那个字符为要提示的文件名
    local file_path="${COMP_WORDS[COMP_CWORD]}"
    
    # 最后要输出的文件提示数组用空格分开
    local file_path_text=""

    # 提示的文件列表
    local file_path_list=($(compgen -f -- $file_path))

    # 将数组分割符 \n -> 空格
    local file
    for file in "${file_path_list[@]}"; do
        file_path_text="$file_path_text $file"
    done


    # 将 compgen 提示模式改成文件提示模式, 即按tab的时候不会自动在最后添加空格(space)
    echo "'{-filenames}' $file_path_text"
}
