# #变量
# ##数组#变量
snippet arrLength "获取数组长度" w
${2:length}=\$\{#${1:数组名}[@]\}
endsnippet

snippet arrIn "判断元素是否在数组中"
if [[ "\$\{${1:arr}[@]\}" =~ "\$\{${2:item}\}" ]]; then
    $0
fi
endsnippet

# ##map#变量
snippet mapInit "初始化map,普通方式定义无法遍历:declare -A map=(['k1']='v1' ['k2']='v2')"
declare -A ${1:map_name}=(${2:初始化值})
$0
endsnippet
snippet mapFor "遍历map"
for ${2:key} in \$\{!${1:map_var_name}[@]\}; do
    ${3:value}=\$\{$1[\$$2]\}
    $0
done
endsnippet
snippet mapForKeys "遍历map keys"
for ${2:key} in \$\{!${1:map_var_name}[@]\}; do
    $0
done
endsnippet
snippet mapForValues "遍历map values"
for ${2:value} in \$\{${1:map_var_name}[@]\}; do
    $0
done
endsnippet

# ##字符串 str#变量
snippet strEquals "比较两个字符串相等" i
if [[ "${1:变量或字面量支持通配符*}" == "${2:变量或字面量支持通配符*}" ]]; then
    $0
fi
endsnippet

snippet strInit "初始化变量"
test -z \$${1:变量名} && $1="${2:初始值}"
endsnippet

snippet strNull "判断字符串为空"
if [[ -z \$${1:变量名} ]]; then
    $0
fi
endsnippet

# ###字符串截取##字符串 str#变量
# ${string: start :length}   从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。
# ${string: start}           从 string 字符串的左边第 start 个字符开始截取，直到最后。
# ${string: 0-start :length} 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。
# ${string: 0-start}         从 string 字符串的右边第 start 个字符开始截取，直到最后。
# ${string#*chars}           从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。
# ${string##*chars}          从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。
# ${string%*chars}           从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。
# ${string%%*chars}          从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。
snippet strSubByIndex "截取字符串根据下标,${'c.biancheng.net': 2 : 9} -> 'biancheng'"
${4:var}=\$\{${1:字符串}: ${2:start启始位置,可以为负数} :${3:length长度,不填写则到最后,为负数则到倒数位置}\}
endsnippet
# 使用 # 号截取右边字符
snippet strSubRightFirst "截取关键字(第一个匹配到的)右边的字符串, ${'c.biancheng.net'#*.} -> 'biancheng.net'"
${3:var}=\$\{${1:字符串}#*${2:关键字}\}
endsnippet
snippet strSubRightLast "截取关键字(最后一个匹配到的)右边的字符串, ${'c.biancheng.net'##*.} -> 'net'"
${3:var}=\$\{${1:字符串}##*${2:关键字}\}
endsnippet
# 使用 % 号截取左边字符
snippet strSubLeftFirst "截取关键字(第一个匹配到的)左边的字符串, ${'c.biancheng.net'%*.} -> 'c'"
${3:var}=\$\{${1:字符串}%%${2:关键字}*\}
endsnippet
snippet strSubLeftLast "截取关键字(最后一个匹配到的)左边的字符串, ${'c.biancheng.net'%%*.} -> 'c.biancheng'"
${3:var}=\$\{${1:字符串}%${2:关键字}*\}
endsnippet


# ##变量 var#变量
snippet varInit "初始化变量"
test -z \$${1:变量名} && $1="${2:初始值}"
endsnippet

snippet varNull "判断字符串为空"
if [[ -z \$${1:变量名} ]]; then
    $0
fi
endsnippet


# 流程控制 if for

# ##if#流程控制
# 常用参数：
# 文件/目录判断：
# [ -a FILE ] 如果 FILE 存在则为真。
# [ -b FILE ] 如果 FILE 存在且是一个块文件则返回为真。
# [ -c FILE ] 如果 FILE 存在且是一个字符文件则返回为真。
# [ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。
# [ -e FILE ] 如果 指定的文件或目录存在时返回为真。
# [ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。
# [ -g FILE ] 如果 FILE 存在且设置了SGID则返回为真。
# [ -h FILE ] 如果 FILE 存在且是一个符号符号链接文件则返回为真。（该选项在一些老系统上无效）
# [ -k FILE ] 如果 FILE 存在且已经设置了冒险位则返回为真。
# [ -p FILE ] 如果 FILE 存并且是命令管道时返回为真。
# [ -r FILE ] 如果 FILE 存在且是可读的则返回为真。
# [ -s FILE ] 如果 FILE 存在且大小非0时为真则返回为真。
# [ -u FILE ] 如果 FILE 存在且设置了SUID位时返回为真。
# [ -w FILE ] 如果 FILE 存在且是可写的则返回为真。（一个目录为了它的内容被访问必然是可执行的）
# [ -x FILE ] 如果 FILE 存在且是可执行的则返回为真。
# [ -O FILE ] 如果 FILE 存在且属有效用户ID则返回为真。
# [ -G FILE ] 如果 FILE 存在且默认组为当前组则返回为真。（只检查系统默认组）
# [ -L FILE ] 如果 FILE 存在且是一个符号连接则返回为真。
# [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则返回为真。
# [ -S FILE ] 如果 FILE 存在且是一个套接字则返回为真。
# [ FILE1 -nt FILE2 ] 如果 FILE1 比 FILE2 新, 或者 FILE1 存在但是 FILE2 不存在则返回为真。
# [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 老, 或者 FILE2 存在但是 FILE1 不存在则返回为真。
# [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则返回为真。
# 字符串判断
# [ -z STRING ]    如果STRING的长度为零则返回为真，即空是真
# [ -n STRING ]    如果STRING的长度非零则返回为真，即非空是真
# [ STRING1 ]　   如果字符串不为空则返回为真,与-n类似
# [ STRING1 == STRING2 ]   如果两个字符串相同则返回为真
# [ STRING1 != STRING2 ]    如果字符串不相同则返回为真
# [ STRING1 < STRING2 ]     如果 “STRING1”字典排序在“STRING2”前面则返回为真。
# [ STRING1 > STRING2 ]     如果 “STRING1”字典排序在“STRING2”后面则返回为真。
# 数值判断
# [ INT1 -eq INT2 ]          INT1和INT2两数相等返回为真 ,=
# [ INT1 -ne INT2 ]          INT1和INT2两数不等返回为真 ,<>
# [ INT1 -gt INT2 ]           INT1大于INT2返回为真 ,>
# [ INT1 -ge INT2 ]          INT1大于等于INT2返回为真,>=
# [ INT1 -lt INT2 ]            INT1小于INT2返回为真 ,<
# [ INT1 -le INT2 ]           INT1小于等于INT2返回为真,<=
# 逻辑判断
# [ ! EXPR ]       逻辑非，如果 EXPR 是false则返回为真。
# [ EXPR1 -a EXPR2 ]      逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
# [ EXPR1 -o EXPR2 ]      逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。
# [  ] || [  ]           用OR来合并两个条件
# [  ] && [  ]        用AND来合并两个条件
# 其他判断
# [ -t FD ]  如果文件描述符 FD （默认值为1）打开且指向一个终端则返回为真
# [ -o optionname ]  如果shell选项optionname开启则返回为真
# IF高级特性：
# 双圆括号((  ))：表示数学表达式
#     在判断命令中只允许在比较中进行简单的算术操作，而双圆括号提供更多的数学符号，而且在双圆括号里面的'>','<'号不需要转意。
# 双方括号[[  ]]：表示高级字符串处理函数
#     双方括号中判断命令使用标准的字符串比较，还可以使用匹配模式，从而定义与字符串相匹配的正则表达式。
# 双括号的作用：
# 在shell中，[ $a != 1 || $b = 2 ]是不允许出，要用[ $a != 1 ] || [ $b = 2 ]，而双括号就可以解决这个问题的，[[ $a != 1 || $b = 2 ]]。又比如这个[ "$a" -lt "$b" ]，也可以改成双括号的形式(("$a" < "$b"))

snippet ifStrEquals "比较两个字符串相等" i
if [[ "${1:变量或字面量支持通配符*}" == "${2:变量或字面量支持通配符*}" ]]; then
    $0
fi
endsnippet

snippet ifStrNull "判断字符串为空"
if [[ -z \$${1:变量名} ]]; then
    $0
fi
endsnippet
snippet ifVarNull "判断字符串为空"
if [[ -z \$${1:变量名} ]]; then
    $0
fi
endsnippet

snippet ifDirExist "判断目录是否存在，要判断不存在加 !"
if [[ -d "${1:目录地址}" ]]; then
    $0
fi
endsnippet
	
snippet ifArrIn "判断元素是否在数组中"
if [[ "\$\{${1:arr}[@]\}" =~ "\$\{${2:item}\}" ]]; then
    $0
fi
endsnippet
snippet ifInArr "判断元素是否在数组中"
if [[ "\$\{${1:arr}[@]\}" =~ "\$\{${2:item}\}" ]]; then
    $0
fi
endsnippet
# ##for#流程控制
snippet forin "遍历数组不带下标"
for ${1:子变量名} in "\$\{${2:父变量名}[@]\}"; do
    $0
done
endsnippet

snippet fori "遍历数组带下标"
for(( ${1:i}=0;$1<\$\{#${2:数组名}[@]\};$1++)) do
    $0\$\{$2[$1]\}
done;
endsnippet
	
snippet forMap "遍历map"
for ${2:key} in \$\{!${1:map_var_name}[@]\}; do
    ${3:value}=\$\{$1[\$$2]\}
    $0
done
endsnippet
snippet forMapKeys "遍历map keys"
for ${2:key} in \$\{!${1:map_var_name}[@]\}; do
    $0
done
endsnippet
snippet forMapValues "遍历map values"
for ${2:value} in \$\{${1:map_var_name}[@]\}; do
    $0
done
endsnippet


# #环境信息
snippet homePath "获取当前执行脚本目录"
home_path=$(readlink -f $(dirname "$0"))
endsnippet

snippet currentPath "获取当前执行脚本目录"
current_path=$(readlink -f $(dirname "$0"))
endsnippet

# ##更改目录#环境信息
# ```shell
# $ pushd /dir1 # 将目录/dir1添加到目录栈中，同时当前目录切换到/dir1
# $ pushd /dir2
# $ pushd /dir3
# $ pushd /dir4
# $ dirs -v # 显示目录栈内容,前面数字为下标
# 0 /dir1 
# 1 /dir2
# 2 /dir3
# 3 /dir4
# $ pushd +2 # 将下标为2的目录作为栈顶，顺序保持不变
# $ dirs -v
# 0 /dir3
# 1 /dir4
# 2 /dir1
# 3 /dir2
# $ popd # 将栈顶移除
# 0 /dir4
# 1 /dir1
# 2 /dir2
# ```
snippet pushd "将一个目录路径添加到／放入目录栈（历史）顶中，之后，你可以浏览位于目录栈（历史）中的任意目录(默认在栈顶)"
pushd ${1:目录}
endsnippet
snippet popd "popd命令会从栈顶移除一个目录,配合poshd使用"
popd
endsnippet
snippet dirs "dirs查看目录栈,配合pushd和popd使用"
dirs -v
endsnippet

# #输入输出
snippet read "读取键盘输入"
read -p "${1:提示信息}" ${2:读取到那个变量}
$0
endsnippet



# #jq
# -R : 将json 转字符串
# -r : 将字符串转json(标准化)。
#      echo '{"k": "v"}' | jq -r ".k" # 输出: v
#      echo '{"k": "v"}' | jq ".k" # 输出: "v"
# -s : 将换行符号转 '\n' 配合保证-R 使用保证json转字符串只有一行
snippet jqGet "jq获取一个字段, key结构如下 : .第一层key.k第二层key (使用'.'分割)"
${3:var}=\$(echo \$${1:json变量} | jq -r ".${2:key}")
$0
endsnippet
snippet jqArrFor "jq遍历jq数组/list 需要 json list 为 : [] 格式"
${1:length}=$(echo \$\{${2:json list变量}\} | jq ". | length")
for (( ${3:i}=0; $3<$1; $3++ )); do
    ${4:jsonListItem}=\$(echo \$$2 | jq -r ".[\$$3]")
    $0
done
endsnippet
snippet jqPutStr "jq put string 类型到json 例子 : {} -> {'k': '[1,2]'}"
${1:json变量}=\$(echo -n \$\{$1\} | jq --arg ${2:key} "${3:value可以使用\$变量}" '.$2=\$$2')
$0
endsnippet
snippet jqPutJson "jq put string 类型到json 例子 : {} -> {'k': [1,2]}"
${1:json变量}=\$(echo -n \$\{$1\} | jq --argjson ${2:key} "${3:value可以使用\$变量}" '.$2=\$$2')
$0
endsnippet
snippet jqDel "jq 删除key : {'k': 'v', 'k1': 'v1'} -> {'k': 'v'}"
${1:json变量}=\$(echo -n \$\{$1\} | jq 'del(.${2:key})')
$0
endsnippet
snippet jqDelArr "jq 删除数组中的元素 : echo '[1,2]' | jq 'del(.[0])' -> [2]"
${1:json变量}=\$(echo -n \$\{$1\} | jq 'del(.${2:key}[${3:index}])')
$0
endsnippet
snippet jqKeys "获取json的所有key"
${2:var,返回格式为json:["k"]}=\$(echo -n \$${1:json_var} | jq "keys")
endsnippet
snippet jqArrAdd "jq 往数组中追加元素 : [1] -> [1,2]"
${1:json变量}=\$(echo -n \$\{$1\} | jq '.${2:key}[length]=${3:value}')
$0
endsnippet
snippet jqArrDel "jq 删除数组中的元素 : echo '[1,2]' | jq 'del(.[0])' -> [2]"
${1:json变量}=\$(echo -n \$\{$1\} | jq 'del(.${2:key}[${3:index}])')
$0
endsnippet

# #curl
snippet curlGet "curl get"
curl -X GET '${1:url}' \
  -H 'Accept: application/json, text/plain, */*' \
  -H 'Connection: keep-alive'
endsnippet
snippet curlPost "curl post"
curl -X POST '${1:url}' \
  -H 'Accept: application/json'  \
  -H 'Content-Type: application/json'  \
  -H 'Connection: keep-alive'  \
  --data-raw '${2:json data}'
endsnippet
snippet curlUploadFile "curl上传文件"
curl '${1:url}' \
  -H 'Content-Type: multipart/form-data'  \
  -H 'Connection: keep-alive'  \
  -F 'file=@${2:filePath}' \
  -F '${3:key普通参数，value不带@}=${4:value}'
endsnippet
snippet curlHeadCookie "添加cookie"
-H "Cookie: $cookie" \
endsnippet
snippet curlHeadLanguage "curl 语言"
-H 'Accept-Language: zh-CN,zh;'  \
endsnippet
