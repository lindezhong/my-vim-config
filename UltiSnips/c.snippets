# c语言代码片段

snippet ifei "if else if"
if(${1:true}) {
	${2}
} else if(${3:true}) {
	${4}
}
${0}
endsnippet

snippet ifeie "if else if else"
if(${1:true}) {
	${2}
} else if(${3:true}) {
	${4}
} else {
	${5}
}
${0}
endsnippet


snippet switch "switch"
switch (${1:value}) {
	case ${2:value1}:
		${3}
		break;
	case ${4:value1}:
		${5}
		break;
	default:
		${6}
		break;
}
${0}
endsnippet


snippet if? "三目运算符"
${1:expression} ? ${2:value1} : ${3:vaue2};
${0}
endsnippet

# #流程控制
# ##goto#流程控制
# goto 的一个主要用法是跳出多层循环。
# 
# ```c
# for(...) {
#   for (...) {
#     while (...) {
#       do {
#         if (some_error_condition)
#           goto bail;
#       } while(...);
#     }
#   }
# }
# bail:
# goto 的另一个用途是提早结束多重判断。
# ```c
# if (do_something() == ERR)
#   goto error;
# if (do_something2() == ERR)
#   goto error;
# if (do_something3() == ERR)
#   goto error;
# if (do_something4() == ERR)
#   goto error;
# ```
# 
# 上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断。
# 
# 注意，goto 只能在同一个函数之中跳转，并不能跳转到其他函数。
snippet goto "goto语句，跳转到label代码处"
${1:label}: ${2}

goto $1;
endsnippet
# #数据类型
# ##整数#数据类型
# unsigned int`里面的`int`可以省略 可以定义成 unsigned i=1;
snippet unsignedi "非负数整数,整数变量声明为`unsigned`的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。比如，16位的`signed int`最大值为32,767，而`unsigned int`的>    最大值增大到了65,535。"
unsigned int ${1:i};
endsnippet
# ###整数的子类型##整数#数据类型
# - `short int`（简写为`short`）：占用空间不多于`int`，一般占用2个字节（整数范围为-32768～32767)。
# - `long int`（简写为`long`）：占用空间不少于`int`，至少为4个字节。
# - `long long int`（简写为`long long`）：占用空间多于`long`，至少为8个字节。
# ###整数进制##整数#数据类型
# 八进制使用`0`作为前缀，比如int i = 017;(等价于int i = 15;)。
# 十六进制使用`0x`或`0X`作为前缀，比如int i = 0xf;(等价于int i = 15;)
# ###整数类型的极限值##整数#数据类型
# 有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件`limits.h`提供了相应的常量，比如`SCHAR_MIN`代表 signed char 类型的最小值`-128`，`SCHAR_MAX`代表 signed char 类型的最大值`127`。
# 为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。
# - `SCHAR_MIN`，`SCHAR_MAX`：signed char 的最小值和最大值。
# - `SHRT_MIN`，`SHRT_MAX`：short 的最小值和最大值。
# - `INT_MIN`，`INT_MAX`：int 的最小值和最大值。
# - `LONG_MIN`，`LONG_MAX`：long 的最小值和最大值。
# - `LLONG_MIN`，`LLONG_MAX`：long long 的最小值和最大值。
# - `UCHAR_MAX`：unsigned char 的最大值。
# - `USHRT_MAX`：unsigned short 的最大值。
# - `UINT_MAX`：unsigned int 的最大值。
# - `ULONG_MAX`：unsigned long 的最大值。
# - `ULLONG_MAX`：unsigned long long 的最大值。
# ##浮点数#数据类型
# float`类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号。`float`类型至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）`-37`到`37`，即数值范围为10<sup>-37</sup>到10<sup>37</sup>
#有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。
# - `double`：占用8个字节（64位），至少提供13位有效数字。
# - `long double`：通常占用16个字节。
# 注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面`0.1 + 0.2`并不等于`0.3`，而是有一个很小的误差。
# ```c
# if (0.1 + 0.2 == 0.3) // false
# ```
# ##布尔类型#数据类型
# 头文件`stdbool.h`定义了另一个类型别名`bool`，并且定义了`true`代表`1`、`false`代表`0`。只要加载这个头文件，就可以使用这几个关键字。
# ```c
# #include <stdbool.h>
# bool flag = false;
# ```
# ## 溢出#数据类型
# 每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢>
# 出（overflow）；小于最小值，叫做向下溢出（underflow）。
# 一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。所以，应该避免溢出。
# ```c
# unsigned char x = 255;
# x = x + 1;
# printf("%d\n", x); // 0
# ##sizeof运算符#数据类型
# `sizeof`是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。
# sizeof(int)=sizeof(1)=4		sizeof(3.4)=8 (浮点数的字面量一律存储为 double 类型)
# ##精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。#数据类型
# `int8_t`：8位有符号整数。 `uint8_t`：8位无符号整数。 同理还有16，32，64位整数
# 上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果`int`类型为32位，`int32_t`就会指向`int`；如果`long`类型为32位，`i    nt32_t`则会指向`long`。

# #指针
# 指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。
# 字符`*`表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，`char*`表示一个指向字符的指针，`float*`表示一个指向`float`类型的值的指针。
# * : 表示取指针指向地址的值 ， & ：表示取变量的地址
# ```c
# // foo 是指针类型，bar是intleix
# int* foo , bar;
# // 指向指针的指针,`foo`是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。
# int** foo;
# // &表示取变量的地址
# int v = 1; int* p = &v;
# // 指针加法 ： * : 表示取指针指向地址的值 , 下面两个方法 p : 地址 , *p : p指向地址的值(为int值)
# void increment(int* p) {
# 	*p = *p + 1;
# }
# void showPointer(int* p) {
#   // p+1 表示指针向内存地址的高位移动一个单位 而int占4位所以 newP - p = 4
# 	int* newP = p + 1;printf("old &p is %p , new &p is %p \n", p, newP); // 输出 : old &p is 0x7fffc26541d0 , new &p is 0x7fffc26541d4
# }
# int v = 1;increment(&v);printf("%d\n",v);// 输出2
# // `&`运算符与`*`运算符互为逆运算
# int i = 5; printf("%d\n",i == *(&i)); // 输出1(true)
# // 返回内部变量指针无效，因为当函数结束运行时，内部变量就消失了，这时指向内部变量`i`的内存地址就是无效的，再去使用这个地址是非常危险的。
# int* print() {int i = 0; return &i;}
# // 函数指针 比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，`print`和`&print`是一回事。
# void print(int n) {printf("%d\n",n);}
# void (*print_ptr)(int) = &print; (*print_ptr)(10); /*等价于*/ print(10);
#  ```

# #函数
# ##函数原型#函数
# int f();
# int main() { f(); };
# int f() {print("函数原型，先定义了f()方法使得f()可以被使用");}
# ##系统函数#函数
# 1. exit(int n) : `函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件`stdlib.h`里面。
# 2. atexit()`函数，用来登记`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件`stdlib.h atexit()`的参数是一个函数指针(它的参数函数不能接受参数，也不能有返回值。)
# ##函数说明符#函数
# ###extern##函数说明符#函数
#extern 对该变量/函数作"外部变量声明",表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。
#include <stdio.h>
# int main(void)
# {
#     extern int g_X;
#     printf("the gloal value is %d\n",int_g_X); // 输出 10
#     return 0;
# }
# /*定义全局变量*/
# int g_X = 10;
# ###static##函数说明符#函数
# 1. 默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。`static`说明符可以改变这种行为。
# 2. 方法用static修饰后只能用在本文件内
# static int f() { static int count = 1; count++; return count; } // 只能在本文件内调用f()
# printf("%d , %d", f(), f()); // 输出 1 ， 2
# ###const##函数说明符#函数
# const等价于java 的 final
# int* const p; // p = 0 报错 ， *p = 1 修改成功
# const int* p; // p = 0 修改成功 ， *p = 1 报错
# const int* const p; // p = 0 和 *p = 0 都报错
# ##可变参数#函数
# ```c
# double average(int i, ...) {
#   double total = 0;
#   va_list ap; // 一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用
#   va_start(ap, i); // 一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。
#   for (int j = 1; j <= i; ++j) {
#     total += va_arg(ap, double); // ：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。
#   }
#   va_end(ap); // 一个函数，用来清理可变参数对象。
#   return total / i;
# }

# #数组
# ```c
# int a[5] = {22, 37, 3490}; /*等价于*/ int a[] = {22, 37, 3490, 0, 0}; /*等价于*/  int a[5] = {[1]=22, 37, [3]=3490}
# size_t length = sizeof(1) / sizeof(a[0]) 
# // 由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组员的字节长度，就可以得到数组的成员数量。
# // 注意，`sizeof`返回值的数据类型是`size_t`，所以`sizeof(a) / sizeof(a[0])`的数据类型也是`size_t`。在`printf()`里面的占位符，要用`%zd`或`%zu`。
# // 注意如果是f(int arr[]) { size_t len = sizeof(arr); } 会报错，因为f()函数中的arr数组作为参数传给函数时，是传给数组的地址，而不是传给整个的数组空间
# ```
# ##数组的地址#数组
# ```c
# //数组名等同于起始地址，也就是说，数组名就是指向第一个成员
# int sum(int* arr, int len); 
# int a[5] = {11, 22, 33, 44, 55}; 
# int* p = &a[0]; /*等价于*/ int* p = a;
# // 例子 : 将数组起始地址作为数组
# sum(a, 5); sum(&a[0], 5);
# // int sum(int* arr, int len) /*等价于*/ int sum(int arr[], int len)
# int sum(int* arr, int len) {
#   int i;
#  	int arrays[] = {1,2,3}; 
#   int total = 0;
#   for (i = 0; i < len; i++) {
#     total += arr[i];
# 	  // total += *(arr++); // (arr实际为指针所以可以自增)数组名可以进行加法和减法运算，等同于在数组成员之间前后移动
#     // arrays++ // 报错(数组名指向的地址是不能变的)
#	}
#   return total;
# }
# // 多维数组中也适用
# int a[4][2]; a[0][0] /*等价于*/ *(a[0] /*等价于*/ **a 
# a+1 = a[1] , a[0]+1 = a[0][1]
# // 数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，
# int a[5];
# int b[5] = {1,2,3,4,5};
# a=NULL; // 报错
# a=b; // 报错 这也导致不能将一个数组名赋值给另外一个数组名。
# ```
# ##数组复制#数组
# int* a; int b[] = {1,2,3}; memcpy(a, b, sizeof(b));
# ##数组参数#数组
# ###二维数组参数##数组参数#数组
# in sum_array(arr[][2], int len);
# // 函数`sum_array()`的参数是一个二维数组。第一个参数是数组本身（`a[][4]`），这时可以不写第一维的长度，因为它作为第二个参数，会传入函 数，但是一定要写第二维的长度`4`。
# // 这是因为函数内部拿到的，只是数组的起始地址`a`，以及第一维的成员数量`2`。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写>    成`int a[][4]`，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是`4 * sizeof(int)`。
# ###变长数组作为参数##数组参数#数组
# int sum_array(int n, int a[n]); // 数组`a[n]`是一个变长数组，它的长度取决于变量`n`的值, n要在a前面定义
# int sum = sum_array(4, (int []){1,2,3,4});
snippet arrFunVarOne "方法中定义一个一维数组参数" i
int ${1:len}, ${2:int} ${3:arrays}[$1]$0
endsnippet
snippet arrFunVarTow "方法中定义一个二维数组参数" i
int ${1:m}, int ${2:n} ${3:int} ${4:arrays}[$1][$2]$0
endsnippet
