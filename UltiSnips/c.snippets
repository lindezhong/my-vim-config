# c语言代码片段

snippet ifei "if else if"
if(${1:true}) {
	${2}
} else if(${3:true}) {
	${4}
}
${0}
endsnippet

snippet ifeie "if else if else"
if(${1:true}) {
	${2}
} else if(${3:true}) {
	${4}
} else {
	${5}
}
${0}
endsnippet


snippet switch "switch"
switch (${1:value}) {
	case ${2:value1}:
		${3}
		break;
	case ${4:value1}:
		${5}
		break;
	default:
		${6}
		break;
}
${0}
endsnippet


snippet if? "三目运算符"
${1:expression} ? ${2:value1} : ${3:vaue2};
${0}
endsnippet

# #流程控制
# ##goto#流程控制
# goto 的一个主要用法是跳出多层循环。
# 
# ```c
# for(...) {
#   for (...) {
#     while (...) {
#       do {
#         if (some_error_condition)
#           goto bail;
#       } while(...);
#     }
#   }
# }
# bail:
# goto 的另一个用途是提早结束多重判断。
# ```c
# if (do_something() == ERR)
#   goto error;
# if (do_something2() == ERR)
#   goto error;
# if (do_something3() == ERR)
#   goto error;
# if (do_something4() == ERR)
#   goto error;
# ```
# 
# 上面示例有四个判断，只要有一个发现错误，就使用 goto 跳过后面的判断。
# 
# 注意，goto 只能在同一个函数之中跳转，并不能跳转到其他函数。
snippet goto "goto语句，跳转到label代码处"
${1:label}: ${2}

goto $1;
endsnippet
# #数据类型
# ##整数#数据类型
# unsigned int`里面的`int`可以省略 可以定义成 unsigned i=1;
snippet unsignedi "非负数整数,整数变量声明为`unsigned`的好处是，同样长度的内存能够表示的最大整数值，增大了一倍。比如，16位的`signed int`最大值为32,767，而`unsigned int`的>    最大值增大到了65,535。"
unsigned int ${1:i};
endsnippet
# ###整数的子类型##整数#数据类型
# - `short int`（简写为`short`）：占用空间不多于`int`，一般占用2个字节（整数范围为-32768～32767)。
# - `long int`（简写为`long`）：占用空间不少于`int`，至少为4个字节。
# - `long long int`（简写为`long long`）：占用空间多于`long`，至少为8个字节。
# ###整数进制##整数#数据类型
# 八进制使用`0`作为前缀，比如int i = 017;(等价于int i = 15;)。
# 十六进制使用`0x`或`0X`作为前缀，比如int i = 0xf;(等价于int i = 15;)
# ###整数类型的极限值##整数#数据类型
# 有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件`limits.h`提供了相应的常量，比如`SCHAR_MIN`代表 signed char 类型的最小值`-128`，`SCHAR_MAX`代表 signed char 类型的最大值`127`。
# 为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。
# - `SCHAR_MIN`，`SCHAR_MAX`：signed char 的最小值和最大值。
# - `SHRT_MIN`，`SHRT_MAX`：short 的最小值和最大值。
# - `INT_MIN`，`INT_MAX`：int 的最小值和最大值。
# - `LONG_MIN`，`LONG_MAX`：long 的最小值和最大值。
# - `LLONG_MIN`，`LLONG_MAX`：long long 的最小值和最大值。
# - `UCHAR_MAX`：unsigned char 的最大值。
# - `USHRT_MAX`：unsigned short 的最大值。
# - `UINT_MAX`：unsigned int 的最大值。
# - `ULONG_MAX`：unsigned long 的最大值。
# - `ULLONG_MAX`：unsigned long long 的最大值。
# ##浮点数#数据类型
# float`类型占用4个字节（32位），其中8位存放指数的值和符号，剩下24位存放小数的值和符号。`float`类型至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）`-37`到`37`，即数值范围为10<sup>-37</sup>到10<sup>37</sup>
#有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。
# - `double`：占用8个字节（64位），至少提供13位有效数字。
# - `long double`：通常占用16个字节。
# 注意，由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面`0.1 + 0.2`并不等于`0.3`，而是有一个很小的误差。
# ```c
# if (0.1 + 0.2 == 0.3) // false
# ```
# ##布尔类型#数据类型
# 头文件`stdbool.h`定义了另一个类型别名`bool`，并且定义了`true`代表`1`、`false`代表`0`。只要加载这个头文件，就可以使用这几个关键字。
# ```c
# #include <stdbool.h>
# bool flag = false;
# ```
# ## 溢出#数据类型
# 每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢>
# 出（overflow）；小于最小值，叫做向下溢出（underflow）。
# 一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。所以，应该避免溢出。
# ```c
# unsigned char x = 255;
# x = x + 1;
# printf("%d\n", x); // 0
# ##sizeof运算符#数据类型
# `sizeof`是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。
# sizeof(int)=sizeof(1)=4		sizeof(3.4)=8 (浮点数的字面量一律存储为 double 类型)
# ##精确宽度类型(exact-width integer type)，保证某个整数类型的宽度是确定的。#数据类型
# `int8_t`：8位有符号整数。 `uint8_t`：8位无符号整数。 同理还有16，32，64位整数
# 上面这些都是类型别名，编译器会指定它们指向的底层类型。比如，某个系统中，如果`int`类型为32位，`int32_t`就会指向`int`；如果`long`类型为32位，`i    nt32_t`则会指向`long`。

# #指针
# 指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。
# 字符`*`表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，`char*`表示一个指向字符的指针，`float*`表示一个指向`float`类型的值的指针。
# * : 表示取指针指向地址的值 ， & ：表示取变量的地址
# ```c
# // foo 是指针类型，bar是intleix
# int* foo , bar;
# // 指向指针的指针,`foo`是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数。
# int** foo;
# // &表示取变量的地址
# int v = 1; int* p = &v;
# // 指针加法 ： * : 表示取指针指向地址的值 , 下面两个方法 p : 地址 , *p : p指向地址的值(为int值)
# void increment(int* p) {
# 	*p = *p + 1;
# }
# void showPointer(int* p) {
#   // p+1 表示指针向内存地址的高位移动一个单位 而int占4位所以 newP - p = 4
# 	int* newP = p + 1;printf("old &p is %p , new &p is %p \n", p, newP); // 输出 : old &p is 0x7fffc26541d0 , new &p is 0x7fffc26541d4
# }
# int v = 1;increment(&v);printf("%d\n",v);// 输出2
# // `&`运算符与`*`运算符互为逆运算
# int i = 5; printf("%d\n",i == *(&i)); // 输出1(true)
# // 返回内部变量指针无效，因为当函数结束运行时，内部变量就消失了，这时指向内部变量`i`的内存地址就是无效的，再去使用这个地址是非常危险的。
# int* print() {int i = 0; return &i;}
# // 函数指针 比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，`print`和`&print`是一回事。
# void print(int n) {printf("%d\n",n);}
# void (*print_ptr)(int) = &print; (*print_ptr)(10); /*等价于*/ print(10);
#  ```

# #函数
# ##函数原型#函数
# int f();
# int main() { f(); };
# int f() {print("函数原型，先定义了f()方法使得f()可以被使用");}
# ##系统函数#函数
# 1. exit(int n) : `函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件`stdlib.h`里面。
# 2. atexit()`函数，用来登记`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件`stdlib.h atexit()`的参数是一个函数指针(它的参数函数不能接受参数，也不能有返回值。)
# ##函数说明符#函数
# ###extern##函数说明符#函数
#extern 对该变量/函数作"外部变量声明",表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。
#include <stdio.h>
# int main(void)
# {
#     extern int g_X;
#     printf("the gloal value is %d\n",int_g_X); // 输出 10
#     return 0;
# }
# /*定义全局变量*/
# int g_X = 10;
# ###static##函数说明符#函数
# 1. 默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。`static`说明符可以改变这种行为。
# 2. 方法用static修饰后只能用在本文件内
# static int f() { static int count = 1; count++; return count; } // 只能在本文件内调用f()
# printf("%d , %d", f(), f()); // 输出 1 ， 2
# ###const##函数说明符#函数
# const等价于java 的 final
# int* const p; // p = 0 报错 ， *p = 1 修改成功
# const int* p; // p = 0 修改成功 ， *p = 1 报错
# const int* const p; // p = 0 和 *p = 0 都报错
# ##可变参数#函数
# ```c
# double average(int argsLength, ...) {
#   double total = 0;
#   va_list ap; // 一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用
#   va_start(ap, argsLength); // 一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。
#   for (int j = 1; j <= argsLength; ++j) {
#     total += va_arg(ap, double); // ：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。
#   }
#   va_end(ap); // 一个函数，用来清理可变参数对象。
#   return total / argsLength;
# }
# double ave = average(3, 1,2,3); // ave=2, 调用方式,请注意需要传递参数中的 argsLength
# ```
snippet argsVariadicDefinition "可变参数定义,调用的时候需传递参数长度argsLength"
int ${1:argsLength}, ...
endsnippet
snippet argsVariadicUse "可变参数使用"
va_list ${1:var};
va_start($1, ${2:argsLength,'...'前的int变量});
for (int ${3:i}=0; $3<$2; $3++) {
    ${4:可变参数类型} ${5:var} = va_arg($1, $4);
	$0
}
va_end($1);
endsnippet

# #数组
# ```c
# int a[5] = {22, 37, 3490}; /*等价于*/ int a[] = {22, 37, 3490, 0, 0}; /*等价于*/  int a[5] = {[1]=22, 37, [3]=3490}
# size_t length = sizeof(1) / sizeof(a[0]) 
# // 由于数组成员都是同一个类型，每个成员的字节长度都是一样的，所以数组整体的字节长度除以某个数组员的字节长度，就可以得到数组的成员数量。
# // 注意，`sizeof`返回值的数据类型是`size_t`，所以`sizeof(a) / sizeof(a[0])`的数据类型也是`size_t`。在`printf()`里面的占位符，要用`%zd`或`%zu`。
# // 注意如果是f(int arr[]) { size_t len = sizeof(arr); } 会报错，因为f()函数中的arr数组作为参数传给函数时，是传给数组的地址，而不是传给整个的数组空间
# ```
snippet arrLength "数组长度"
size_t ${2:length}=sizeof(${1:arr_var})/sizeof($1[0]);
$0
endsnippet
# ##数组的地址#数组
# ```c
# //数组名等同于起始地址，也就是说，数组名就是指向第一个成员
# int sum(int* arr, int len); 
# int a[5] = {11, 22, 33, 44, 55}; 
# int* p = &a[0]; /*等价于*/ int* p = a;
# // 例子 : 将数组起始地址作为数组
# sum(a, 5); sum(&a[0], 5);
# // int sum(int* arr, int len) /*等价于*/ int sum(int arr[], int len)
# int sum(int* arr, int len) {
#   int i;
#  	int arrays[] = {1,2,3}; 
#   int total = 0;
#   for (i = 0; i < len; i++) {
#     total += arr[i];
# 	  // total += *(arr++); // (arr实际为指针所以可以自增)数组名可以进行加法和减法运算，等同于在数组成员之间前后移动
#     // arrays++ // 报错(数组名指向的地址是不能变的)
#	}
#   return total;
# }
# // 多维数组中也适用
# int a[4][2]; a[0][0] /*等价于*/ *(a[0] /*等价于*/ **a 
# a+1 = a[1] , a[0]+1 = a[0][1]
# // 数组名指向的地址是不能更改的。声明数组时，编译器自动为数组分配了内存地址，这个地址与数组名是绑定的，不可更改，
# int a[5];
# int b[5] = {1,2,3,4,5};
# a=NULL; // 报错
# a=b; // 报错 这也导致不能将一个数组名赋值给另外一个数组名。
# ```
# ##数组复制#数组
# int* a; int b[] = {1,2,3}; memcpy(a, b, sizeof(b));
snippet arrCopy "数组复制"
memcpy(${1:目标数组名}, ${2:源数组名}, sizeof($2));
endsnippet
# ##数组参数#数组
# ###二维数组参数##数组参数#数组
# in sum_array(arr[][2], int len);
# // 函数`sum_array()`的参数是一个二维数组。第一个参数是数组本身（`a[][4]`），这时可以不写第一维的长度，因为它作为第二个参数，会传入函 数，但是一定要写第二维的长度`4`。
# // 这是因为函数内部拿到的，只是数组的起始地址`a`，以及第一维的成员数量`2`。如果要正确计算数组的结束地址，还必须知道第一维每个成员的字节长度。写成`int a[][4]`，编译器就知道了，第一维每个成员本身也是一个数组，里面包含了4个整数，所以每个成员的字节长度就是`4 * sizeof(int)`。
# ###变长数组作为参数##数组参数#数组
# int sum_array(int n, int a[n]); // 数组`a[n]`是一个变长数组，它的长度取决于变量`n`的值, n要在a前面定义
# int sum = sum_array(4, (int []){1,2,3,4});
snippet argsArrFunVarOne "方法中定义一个一维数组参数" i
int ${1:len}, ${2:int} ${3:arrays}[$1]$0
endsnippet
snippet argsArrFunVarTow "方法中定义一个二维数组参数" i
int ${1:m}, int ${2:n} ${3:int} ${4:arrays}[$1][$2]$0
endsnippet

# #字符串
# C 语言没有单独的字符串类型，字符串被当作字符数组，即char 类型的数组。比如，字符串"Hello"等价于{'H','e','l','l','o','\0'} . '\0' = false
# 所有字符串的最后一个字符，都是\0 。这样做的好处是，C 语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是\0 ，那么就知道字符串结束了。所以char localStr[10];最多只能容纳9个字符的字符串。
# ##字符串定义#字符串
# ```c
# char str[5]="Hello"; // 报错,因为字符串“hello”的实际长度6,在末尾有 '\0',如果定义的长度大于6(str[100]),则后面都填充'\0'
# char str[6]={'H','e','l','l','o','\0'};
# char str[]="Hello"; // 自动推断长度
# char* str="Hello";
# char str[]="hello \
# world"; // str = "hello world" 第一行尾部的反斜杠，将字符串拆成两行,上面这种写法有一个缺点，就是第二行必须顶格书写，如果想包含缩进，那么缩进也会被计入字符串
# char str[]="hel""lo"; // str = "hello"
# ```
# ##字符指针与字符数组的差异#字符串
# ```c
# // 1. 字符串指针(但用malloc()分配出来的可以修改)为常量无法修改,字符串数组可以被修改
# // 原因是系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区
# // 声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。
# char* str="Hello"; str[0]='h'; // 报错
# char str[]="Hello"; str[0]='h'; // 不报错,str被修改,str="hello"
# // 2. 指针变量可以指向其它字符串。字符数组变量不能指向另一个字符串。
# // 原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C 语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。
# char* str="Hello"; str="hello"; // 不报错
# char str[]="Hello"; str="hello"; // 报错
# ```
# ##字符串函数#字符串
# - strlen(const char *) : 获取字符串长度 char s[50]="Hello"; strlen(s)=5; sizeof(s)=50;
snippet strLength "获取字符串长度"
int ${2:length} = strlen(${1:str_var});
endsnippet
# - strcpy(char *, const char *) : 复制字符串 。复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，
snippet strCopy "复制字符串,dest:必须是数组不能是指针，有返回值,必须要保证目标字符串的长度不小于源字符串参数，否则虽然不会报错"
strcpy(${1:dest}, ${2:src});
endsnippet
# - strncpy(char *, const char *, unsigned long) : strncpy() 跟strcpy() 的用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界。  
snippet strCopyN "复制n个长度src字符串,dest:必须是数组不能是指针，有返回值"
strncpy(${1:dest}, ${2:src},${3:n});
endsnippet
# - strcat(char *, const char *) : 它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。
snippet strCat "连接字符串,第一个参数只能是数组不能为指针，把第二个字符串的副本添加到第一个字符串的末尾,注意不要超过第一个字符串长度"
strcat(${1:追加字符串}, ${2:var});
endsnippet
# - strncat(char *, const char *, unsigned long) : strncat() 用于连接两个字符串，用法与strcat() 完全一致，只是增加了第三个参数，指定最大添加的字符数一旦达到指定的字符数，或者在源字符串中遇到空字符\0 ，就不再添加了。
snippet strCatN "连接字符串,第一个参数只能是数组不能为指针,把第二个字符串的副本添加到第一个字符串的末尾,并指定长度n, strncat('world', 'ldz', 3) -> 'world ldz'"
strncat(${1:追加字符串}, ${2:var},${3:n});
endsnippet
# - int strcmp(const char* s1, const char* s2) : 函数用于比较两个字符串的内容。如果s1 小于s2 ，strcmp() 返回值小于0；如果s1 大于s2 ，返回值大于0。
# - strncmp() : 由于strcmp() 比较的是整个字符串，C 语言又提供了strncmp() 函数，只比较到指定的位置。
# - sprintf(char* s, const char* format, ...) : 函数跟printf() 类似，但是用于将数据写入字符串s
snippet strPrintf "函数跟printf() 类似，但是用于将数据写入字符串str,str为数组不能为指针,注意写入长度不要超过str长度"
sprintf(${1:str}, ${2:format}, ${3:...});
endsnippet
# - snprintf(char*s, size_t n, const char* format, ...) : 用来控制写入变量的字符串不超过n - 1
snippet strPrintfN "函数跟printf() 类似，但是用于将数据写入字符串str,并且控制写入变量的字符串不超过n - 1,str为数组不能为指针,注意写入长度不要超过str长度"
snprintf(${1:str}, ${2:n}, ${3:format}, ${4:...});
endsnippet
# ##字符串数组#字符串
# char weekdays[7][10]={"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"}
# char weekdays[][10]={"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"} //二维数组第一维的长度由编译器根据后面的赋值
# char* weekdays[]={"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"} // 其实是一个一维数组，成员就是7个字符指针，每个指针指向一个字符串
# #内存
# 系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为”栈“（stack），”栈“所在的内存是系统自动管理的。
# 用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，它就一直占用内存，直到程序退出，这种情况称为”内存泄漏“（memory leak）。这些变量所在的内存称为”堆“（heap），”堆“所在的内存是用户手动管理的。
# ##void 指针#内存
# void指针:只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。另一方面void 指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据,void 指针与其他所有类型指针之间是互相转换关系
# ```c
# int x = 10; 
# void* p = &x; // 整数指针转为 void 指针
# int* q = p; // void 指针转为整数指针
# printf("%c\n", *p); // 报错(Argument type 'void' is incomplete):由于不知道 void 指针指向什么类型的值，所以不能用`*`运算符取出它指向的值。
# ```
# ##内存相关函数#内存
# void* malloc(size_t size) : 函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。
# ```c
# int* p = (int*) malloc(sizeof(int));
# // `malloc()`分配内存有可能分配失败，这时返回常量 NULL。Null 的值为0，是一个无法读写的内存地址，
# if (p == NULL && !p) {printf("内存分配失败\n");}
# *p = 12;
# // `malloc()`用来创建数组，有一个好处，就是它可以创建动态数组，即根据成员数量的不同，而创建长度不同的数组。
# int* arr = (int*)malloc(n * sizeof(int));
# char* str = malloc(11);
# strcpy(str, "hello world"); // 用malloc分配出来的字符串不是不可变的，可以被修改
# ```
snippet memoryMalloc "内存分配(分配在堆中),不会初始化内存,这个内存块会一直占用到程序运行结束,分配内存有可能分配失败，这时返回常量 NULL。"
${1:type}* ${2:var} = malloc(sizeof($1));
$0
endsnippet
snippet memoryFree "用于释放`malloc()`函数分配的内存，，不释放内存块会一直占用到程序运行结束。分配的内存块一旦释放，就不应该再次操作已经释放的地址，包括重新`free()`"
free(${1:var});
$0
endsnippet
# ```c
# int* p = calloc(10, sizeof(int));
# 
# // 等同于
# int* p = malloc(sizeof(int) * 10);
# memset(p, 0, sizeof(int) * 10);
# ```
snippet memoryCalloc "内存分配(分配在堆中),会将所分配的内存全部初始化为0。分配大小: n*size。这个内存块会一直占用到程序运行结束,分配内存有可能分配失败，这时返回常量 NULL。"
void* ${3:var} = calloc(${1:n}, ${2:size});
$0
endsnippet
# 修改已分配的内存块大小失败返回NULL。block=NULL等价于malloc(),size=0就会释放掉内存块。会复制原有数据,缩小:丢弃超出的部分>    优先在原有内存块上进行缩减,放大:不初始化内存,可以手动调用memset(),注意，`realloc()`不会对内存块进行初始化。
snippet memoryRealloc "修改已分配的内存块大小失败返回NULL。block=NULL等价于malloc(),size=0就会释放掉内存块。会复制原有数据"
${1:block} = realloc($1, ${2:size};
$0
endsnippet
# ```c
# //不管传入的`dest`和`src`是什么类型的指针，将它们重新定义成一字节的 Char 指针，这样就可以逐字节进行复制。`*d++ = *s++`语句相当于先执行`*d = *s`（源字节的值复制给目标字节），然后各自移动到下一个字节。最后，返回复制后的`dest`指针，便于后续使用。
# void* my_memcpy(void* dest, void* src, int byte_count) {
#   char* s = src;
#   char* d = dest;
#   while (byte_count--) {
#     *d++ = *s++;
#   }
#   return dest;
# }
# ```
snippet memoryMemcpy "用于将一块内存拷贝到另一块内存,指定复制长度n,目标区域与源区域不允许重叠,有重叠使用memmove()"
memcpy(${1:dest}, ${2:src}, ${3:n});
$0
endsnippet
# ```c
# int a[100];
# memmove(&a[0], &a[1], 99 * sizeof(int));
# ```
snippet memoryMemmove "函数用于将一段内存数据复制到另一段内存。允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与`memcpy()`行为相同。"
memmove(${1:dest}, ${2:src}, ${3:n});
$0
endsnippet
snippet memoryMemcmp "比较两个内存区域,指定长度n,如果`s1`大于`s2`，返回大于0的整数；如果`s1`小于`s2`，返回小于0的整数。"
int ${4:var} = memcmp(${1:s1}, ${2:s2}, ${3:n});
endsnippet
# ##restrict(受限指针)#内存
# 声明指针变量时，可以使用`restrict`说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restrict pointer）。但实际上能访问只是告诉编译器用于优化
# ```c
# int* restrict p;
# p = malloc(sizeof(int));
# 
# int* q = p;
# *q = 0; //不报错，但现在该内存有`p`和`q`两种访问方式, 后面通过`*q`对该内存区域赋值，会导致未定义行为。
# ```
# #struct
# `struct`关键字，允许自定义复合数据类型，将不同类型的值组合在一起,`struct`结构占用的存储空间(存储空间连续)，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。
# ```c
# struct foo {
#   int a;
#   char* b;
#   char c;
# };
# printf("%d\n", sizeof(struct foo)); // 24
# // 上面示例中，struct foo 有三个属性，在64位计算机上占用的存储空间分别是：int a 占4个字节，指针char* b 占8个字节，char c 占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，struct foo 会占用24个字节，原因是它最大的内存占用属性是char* b 的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个struct foo 就是24个字节（8 * 3）。
# // 多出来的存储空间，都采用空位填充，所以上面的struct foo 真实的结构其实是下面这样
# struct foo {
#   int a;        // 4
#   char pad1[4]; // 填充4字节
#   char *b;      // 8
#   char c;       // 1
#   char pad2[7]; // 填充7字节
# };
# printf("%d\n", sizeof(struct foo)); // 24
# // 为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。
# // 由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。
# struct foo {
#   char c;
#   int a;
#   char* b;
# };
# printf("%d\n", sizeof(struct foo)); // 16
# // 上面示例中，占用空间最小的char c 排在第一位，其次是int a ，占用空间最大的char* b 排在最后。整个strct foo 的内存占用就从24字节下降到16字节。
# 
# // 使用
# struct foo f1 = {'c',3,"hello"};
# // struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。
# struct book {
#   char title[500];
#   char author[100];
#   float value;
# } b1;
# // 上面的语句同时声明了数据类型book 和该类型的变量b1 。如果类型标识符book 只用在这一个地方，后面不再用到，这里可以将类型名省略(struct 声明了一个匿名数据类型，然后又声明了这个类型的变量b1)。
# struct {
#   char title[500];
#   char author[100];
#   float value;
# } b1;
# // 与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。
# struct {
#   char title[500];
#   char author[100];
#   float value;
# } b1 = {"Harry Potter", "J. K. Rowling", 10.0},
#   b2 = {"Cancer Ward", "Aleksandr Solzhenitsyn", 7.85};
# // 指针变量也可以指向struct 结构。
# struct book {
#   char title[500];
#   char author[100];
#   float value;
# }* b1;
# // 或者写成两个语句
# struct book {
#   char title[500];
#   char author[100];
#   float value;
# };
# struct book* b1;
# ```
snippet structDefinition "定义一个struct结构,1.结构名:如果为空为匿名结构,匿名结构一定需要变量名 2.变量名:如果不为空则表示定义了一个struce变量,可以在变量名后直接赋值 = {} 3. 可以使用指针变量 * 变量名"
struct ${1:[结构名]} \{
$0
\} ${2:[变量名]};
endsnippet
snippet structInit "初始化一个struct类型的变量(给struct类型赋初始值) 如 : struct Book b1 = {'name'}"
struct ${1:结构名} ${2:变量名} = \{${3:按顺序的变量值}\};
endsnippet
# ##struct复制#struct
# struct 变量可以使用赋值运算符（= ），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。
# ```c
# struct cat { char name[30]; short age; } a, b;
# strcpy(a.name, "Hula");
# a.age = 3;
# b = a;
# b.name[0] = 'M';
# printf("%s\n", a.name); // Hula
# printf("%s\n", b.name); // Mula
# // 但 如果cat.name类型char*(字符指针)这时a 赋值给b ，导致b.name 也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的
# ```
# ##struct指针#struct
# 如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本,对于 struct 变量名，使用点运算符（. ）获取属性；对于 struct 变量指针，使用箭头运算符（-> ）获取属性。
# ```c
# #include <stdio.h>
# struct turtle {
#   char* name;
#   char* species;
#   int age;
# };
# void happy(struct turtle t) {
#   t.age = t.age + 1; // 为struct原始值的副本,无法修改传入的struct
# }
# void happy(struct turtle* t) {
#   // (*t).age 不能写成*t.age ，因为点运算符. 的优先级高于* 。*t.age 这种写法会将t.age 看成一个指针，然后取它对应的值，会出现无法预料的结果。
#   (*t).age = (*t).age + 1; // 为指针可以修改传入struct内部值
#   t->age = t->age + 1; // (*t).age 这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（-> ），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。
# }
# int main() {
#   struct turtle myTurtle = {"MyTurtle", "sea turtle", 99};
#   happy(myTurtle);
#   printf("Age is %i\n", myTurtle.age); // 输出 99
#   happy(&myTurtle);
#   printf("Age is %i\n", myTurtle.age); // 输出 101
#   return 0;
# }
# ```
# ## struct嵌套#struct
# ```c
# struct species {
#   char* name;
#   int kinds;
# };
# struct fish {
#   char* name;
#   int age;
#   struct species breed;
# };
# // 初始化带嵌套的struct
# // 写法1
# struct fish shark = {"shark", 9, {"Selachimorpha", 500}};
# struct species myBreed = {"Selachimorpha", 500};
# // 写法2
# struct fish shark = {"shark", 9, myBreed};
# // 写法3
# struct fish shark = {
#   .name="shark",
#   .age=9,
#   .breed={"Selachimorpha", 500}
# };
# // 写法4
# struct fish shark = {
#   .name="shark",
#   .age=9,
#   .breed.name="Selachimorpha",
#   .breed.kinds=500
# };
# 
# // 例子
# struct node {
#   int data;
#   struct node* next;
# };
# struct node* head;
# // 生成一个三个节点的列表 (11)->(22)->(33)
# head = malloc(sizeof(struct node));
# head->data = 11;
# head->next = malloc(sizeof(struct node));
# head->next->data = 22;
# head->next->next = malloc(sizeof(struct node));
# head->next->next->data = 33;
# head->next->next->next = NULL;
# // 遍历这个列表
# for (struct node *cur = head; cur != NULL; cur = cur->next) {
#   printf("%d\n", cur->data);
# }
# ```
# ##位字段#struct
# ```c
# struct {
#   unsigned int field1 : 1;
#   unsigned int        : 2;
#   unsigned int field2 : 1;
#   unsigned int        : 0;
#   unsigned int field3 : 1;
# } syntg;
# synth.field1 = 0;
# synth.field2 = 1;
# // 属性后面的:1 ，表示指定这些属性只占用一个二进制位。synth.field1 与synth.field2 之间，有一个宽度为两个二进制位的未命名属性
# ```
# ##弹性数组成员#struct
# 很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。
# ```c
# struct vstring {
#   int len;
#   char chars[];
# };
# struct vstring* str = malloc(sizeof(struct vstring) + n * sizeof(char));
# str->len = n;
# // chars 数组到底有多少个成员，可以在为vstring 分配内存时确定。
# // 上面示例中，假定chars 数组的成员数量是n ，只有在运行时才能知道n 到底是多少。然后，就为struct vstring 分配它需要的内存：它本身占用的内存长度，再加上n 个数组成员占用的内存长度。最后，len 属性记录一下n 是多少。
# // 这样就可以让数组chars 有n 个成员，不用事先确定，可以跟运行时的需要保持一致。
# // 弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。
# ```


	

	



# # #c语言关键字
# - const : 常量
# - extern : 对该变量/函数作"外部变量声明",表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量
